# 20251111 P15: 병합 후 올바른 위치 하이라이트 수정

## 문제

### 증상

```
5개 area: [A, B, C, D, E] (인덱스 0, 1, 2, 3, 4)

Step 1: A+B 병합
- 프리뷰: A(0), B(1) row 하이라이트 ✓
- 병합 후: A+B(0) row 하이라이트 ✓

Step 2: D+E 병합
- 프리뷰: D(3), E(4) column 하이라이트 ✓
- 병합 후: A+B(0) row 하이라이트 ✗ (틀림!)
- 기대: D+E(3) column 하이라이트
```

### 원인

**코드 분석:**

```python
def _complete_next_step(self):
    # ...
    # Find the first merged cluster (tuple/list)
    for idx, label in enumerate(labels):
        if isinstance(label, (tuple, list)):
            self.merged_cluster_idx = idx  # 첫 번째 tuple!
            break
```

**문제:**
- "첫 번째 tuple"을 찾고 있음
- 이전 step에서 이미 병합된 클러스터가 있으면 그걸 찾음
- **방금 병합된 클러스터**를 찾아야 하는데!

### 예시

```
Step 0: [A, B, C, D, E]

Step 1: A+B 병합
  Labels: [A+B, C, D, E]
           ^--- 인덱스 0, tuple

Step 2: D+E 병합 (인덱스 2, 3)
  Labels: [A+B, C, D+E]
           ^------- 인덱스 0, 첫 번째 tuple (A+B) ✗
                ^-- 인덱스 2, 방금 병합된 tuple (D+E) ✓

코드는 A+B(인덱스 0)를 찾아버림!
```

## 해결 방법

### 핵심 아이디어

**프리뷰 단계에서 이미 계산한 정보 활용:**
- `preview_clusters = (idx_i, idx_j)`: 병합될 클러스터의 인덱스
- 병합 후, 새 클러스터는 **더 작은 인덱스** 위치에 생김
- (clustering_steps.py의 `_merge_matrix`에서 보장)

### 구현

**acc_gui.py - StepMatrixWidget._complete_next_step()**

```python
def _complete_next_step(self):
    """Complete the transition to next step"""
    # 1. Preview clusters 정보 저장 (clear하기 전에)
    preview_idx_i, preview_idx_j = None, None
    if self.preview_clusters:
        preview_idx_i, preview_idx_j = self.preview_clusters
        # Ensure idx_i < idx_j
        if preview_idx_i > preview_idx_j:
            preview_idx_i, preview_idx_j = preview_idx_j, preview_idx_i

    # 2. Move to next step
    self.is_preview_mode = False
    self.preview_clusters = None
    self.step_slider.setValue(self.current_step + 1)

    # 3. Highlight merged cluster
    # 병합된 클러스터는 더 작은 인덱스(preview_idx_i) 위치에 있음
    if preview_idx_i is not None:
        self.merged_cluster_idx = preview_idx_i  # 더 작은 인덱스!
        self.highlight_merged = True
        self.update_step_display()

        # After 500ms, remove highlight
        QTimer.singleShot(500, self._remove_highlight)
```

### 동작 원리

```python
# 예: D(인덱스 3)와 E(인덱스 4) 병합

# next_step()에서:
preview_clusters = (3, 4)  # D, E의 인덱스

# _complete_next_step()에서:
preview_idx_i = 3  # 더 작은 인덱스
preview_idx_j = 4

# 병합 후:
merged_cluster_idx = 3  # D+E는 인덱스 3 위치에!
```

## 예시 분석

### Case 1: 앞쪽 클러스터 병합

```
[A, B, C, D, E]  (인덱스 0, 1, 2, 3, 4)

A(0) + B(1) 병합:
- preview_clusters = (0, 1)
- preview_idx_i = 0 (더 작은 값)
- 병합 후 merged_cluster_idx = 0
- 결과: [A+B, C, D, E]
         ^--- 인덱스 0에 A+B ✓
```

### Case 2: 뒤쪽 클러스터 병합

```
[A+B, C, D, E]  (인덱스 0, 1, 2, 3)

D(2) + E(3) 병합:
- preview_clusters = (2, 3)
- preview_idx_i = 2 (더 작은 값)
- 병합 후 merged_cluster_idx = 2
- 결과: [A+B, C, D+E]
              ^--- 인덱스 2에 D+E ✓
```

### Case 3: 중간 클러스터 병합

```
[A+B, C, D, E, F]  (인덱스 0, 1, 2, 3, 4)

C(1) + E(3) 병합:
- preview_clusters = (1, 3)
- preview_idx_i = 1 (더 작은 값)
- 병합 후 merged_cluster_idx = 1
- 결과: [A+B, C+E, D, F]
              ^--- 인덱스 1에 C+E ✓
```

## clustering_steps.py와의 관계

**clustering_steps.py - _merge_matrix()**

```python
# Find indices of clusters to merge
idx_i = 클러스터_i의_인덱스
idx_j = 클러스터_j의_인덱스

# Ensure idx_i < idx_j (swap if needed)
if idx_i > idx_j:
    idx_i, idx_j = idx_j, idx_i

# Create new labels: merged cluster at idx_i position
for old_idx in range(n):
    if old_idx == idx_i:
        new_labels.append(merged_cluster)  # idx_i 위치에!
    elif old_idx == idx_j:
        continue  # idx_j는 제거
    else:
        new_labels.append(labels[old_idx])
```

**보장 사항:**
- 병합된 클러스터는 항상 **더 작은 인덱스 위치**에 배치
- acc_gui.py는 이 규칙에 의존

## 테스트 시나리오

### 시나리오 1: 순차적 병합

```
Step 0: [A, B, C, D, E]

Step 1: A+B (인덱스 0, 1)
- 프리뷰: row 0, 1 하이라이트
- 병합 후: row 0 하이라이트 (A+B)
- 결과: [A+B, C, D, E]

Step 2: D+E (인덱스 2, 3)
- 프리뷰: column 2, 3 하이라이트
- 병합 후: column 2 하이라이트 (D+E) ✓
- 결과: [A+B, C, D+E]
```

### 시나리오 2: 이미 병합된 것과 병합

```
Step 0: [A, B, C, D, E]

Step 1: A+B (인덱스 0, 1)
- 결과: [A+B, C, D, E]

Step 2: C+D (인덱스 1, 2)
- 결과: [A+B, C+D, E]

Step 3: (A+B)+(C+D) (인덱스 0, 1)
- 프리뷰: row 0, row 1 하이라이트
- 병합 후: row 0 하이라이트 (A+B+C+D) ✓
- 결과: [A+B+C+D, E]
```

## 이전 방법과 비교

### Before (틀림)

```python
# "첫 번째 tuple" 찾기
for idx, label in enumerate(labels):
    if isinstance(label, (tuple, list)):
        self.merged_cluster_idx = idx  # 첫 번째 tuple
        break

문제:
- Step 2에서 D+E 병합 시
- [A+B, C, D+E] 중 첫 번째 tuple인 A+B(인덱스 0) 찾음
- D+E(인덱스 2)를 찾아야 하는데!
```

### After (맞음)

```python
# Preview 정보 활용
preview_idx_i, preview_idx_j = self.preview_clusters
if preview_idx_i > preview_idx_j:
    preview_idx_i, preview_idx_j = preview_idx_j, preview_idx_i

self.merged_cluster_idx = preview_idx_i  # 더 작은 인덱스

해결:
- Step 2에서 D+E 병합 시
- preview_clusters = (2, 3)
- merged_cluster_idx = 2 (D+E의 위치) ✓
```

## Fallback 로직

```python
elif self.step_manager and self.current_step > 0:
    # Fallback: find any merged cluster
    step_info = self.step_manager.get_step(self.current_step)
    labels = step_info['labels']
    for idx, label in enumerate(labels):
        if isinstance(label, (tuple, list)):
            self.merged_cluster_idx = idx
    # ...
```

**목적:**
- preview_clusters가 없는 경우 (예: 슬라이더로 직접 이동)
- 정상적인 Next 버튼 사용 시에는 실행되지 않음

## Upper Triangle과의 관계

```
Upper Triangle:
       0   1   2   3   4
0      -   *   *   *   *   ← row 0
1          -   *   *   *   ← row 1
2              -   *   *   ← row 2
3                  -   *   ← row 3
4                      -
       ↑   ↑   ↑   ↑   ↑
     col col col col col
       0   1   2   3   4

병합 후 하이라이트:
- 인덱스 k의 row + column 모두 하이라이트
- i == k (row) 또는 j == k (column)
```

## 장점

### 1. 정확성
- 항상 **방금 병합된 클러스터**를 하이라이트
- 이전 병합과 구분 가능

### 2. 일관성
- Preview 위치와 병합 후 위치가 일치
- 사용자 혼란 감소

### 3. 효율성
- 이미 계산된 정보 재활용
- 추가 검색 불필요

## 테스트

```bash
$ python acc_gui.py
# Load sample_subordinate.csv
# Click Next multiple times
```

**확인 항목:**
1. ✅ Step 1: 앞쪽 병합 → 올바른 위치 하이라이트
2. ✅ Step 2: 뒤쪽 병합 → 올바른 위치 하이라이트 (이 문제 해결!)
3. ✅ Step 3+: 연속 병합 → 항상 올바른 위치
4. ✅ 0.5초 후 하얀색으로 변경

## 결론

Preview clusters 정보를 활용하여 병합 후 올바른 위치 하이라이트:
- ✅ **더 작은 인덱스** 위치 사용
- ✅ "첫 번째 tuple" 대신 "방금 병합된 클러스터"
- ✅ clustering_steps.py의 병합 규칙과 일치
- ✅ 모든 병합 케이스에서 정확

**사용자가 어느 클러스터가 방금 병합되었는지 명확히 확인할 수 있습니다!**
