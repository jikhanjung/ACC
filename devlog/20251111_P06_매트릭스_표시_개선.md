# 20251111 P06: 매트릭스 표시 개선

## 개요

사용자 요청에 따라 두 가지 개선:
1. 병합된 클러스터가 앞쪽 클러스터 위치에 표시되도록
2. Matrix에서 대각선과 lower triangle 숫자 숨기기

## 1. 병합 클러스터 위치 수정

### 문제 (Before)

```
Step 0: [J, T, Y, N, O, Q]
Step 1: [Y, N, O, Q, J+T]  ← J+T가 맨 뒤로
Step 2: [Y, N, J+T, O+Q]   ← O+Q가 맨 뒤로
```

병합된 클러스터가 항상 맨 뒤에 추가되어 순서가 뒤섞임.

### 해결 (After)

```
Step 0: [J, T, Y, N, O, Q]
Step 1: [J+T, Y, N, O, Q]  ← J의 위치에 J+T
Step 2: [J+T, Y, N, O+Q]   ← O의 위치에 O+Q
Step 3: [J+T+Y, N, O+Q]    ← J+T의 위치에 J+T+Y
```

병합된 클러스터가 앞쪽 클러스터(더 작은 인덱스)의 위치를 유지.

### 구현 (_merge_matrix 함수)

#### 핵심 로직

```python
# 1. 두 클러스터의 인덱스 찾기
idx_i = 인덱스_찾기(cluster_i)
idx_j = 인덱스_찾기(cluster_j)

# 2. idx_i < idx_j 보장 (swap if needed)
if idx_i > idx_j:
    idx_i, idx_j = idx_j, idx_i

# 3. 새 labels 생성: idx_i 위치에 병합 클러스터
new_labels = []
for old_idx in range(n):
    if old_idx == idx_i:
        new_labels.append(merged_cluster)  # J+T
    elif old_idx == idx_j:
        continue  # 제거
    else:
        new_labels.append(labels[old_idx])  # 유지
```

#### Matrix 값 계산

```python
# 병합 클러스터와 다른 클러스터 k 간의 similarity
# = (cluster_i와 k의 similarity + cluster_j와 k의 similarity) / 2

for k in other_clusters:
    if k는 병합된 클러스터:
        new_matrix[merged_idx, k] = 1.0  # 자기 자신
    else:
        avg_sim = (matrix[idx_i, k] + matrix[idx_j, k]) / 2.0
        new_matrix[merged_idx, k] = avg_sim
        new_matrix[k, merged_idx] = avg_sim  # 대칭
```

### 예시

#### 원본 (Step 0)
```
       J    T    Y    N    O    Q
J    1.0  0.9  0.8  0.4  0.35 0.36
T    0.9  1.0  0.8  0.38 0.33 0.34
Y    0.8  0.8  1.0  0.37 0.32 0.33
N    0.4  0.38 0.37 1.0  0.75 0.75
O    0.35 0.33 0.32 0.75 1.0  0.85
Q    0.36 0.34 0.33 0.75 0.85 1.0
```

#### Step 1: J(0) + T(1) → J+T(0)
```
       J+T  Y    N    O    Q
J+T    1.0  0.8  0.39 0.34 0.35
Y      0.8  1.0  0.37 0.32 0.33
N      0.39 0.37 1.0  0.75 0.75
O      0.34 0.32 0.75 1.0  0.85
Q      0.35 0.33 0.75 0.85 1.0
```

계산 예:
- `J+T - Y`: (0.8 + 0.8) / 2 = 0.8
- `J+T - N`: (0.4 + 0.38) / 2 = 0.39
- `J+T - O`: (0.35 + 0.33) / 2 = 0.34

## 2. Matrix 표시 개선

### 문제 (Before)

Matrix 전체 값 표시:
```
       J    T    Y
J    1.0  0.9  0.8
T    0.9  1.0  0.8  ← 중복 (대칭)
Y    0.8  0.8  1.0  ← 중복
```

- 대각선 (1.0): 의미 없음 (자기 자신)
- Lower triangle: Upper triangle과 중복 (대칭 행렬)
- 헷갈리고 불필요한 정보

### 해결 (After)

Upper triangle만 표시:
```
       J    T    Y
J      -   0.9  0.8
T          -    0.8
Y               -
```

- Diagonal: 회색 배경, 빈 칸
- Lower triangle: 빈 칸
- Upper triangle: 값 표시

### 구현 (populate_table 함수)

```python
def populate_table(self, matrix, labels):
    for i in range(n):
        for j in range(n):
            if i < j:
                # Upper triangle: 값 표시
                item = QTableWidgetItem(f"{matrix[i, j]:.3f}")
                if is_merged_cluster(i) or is_merged_cluster(j):
                    item.setBackground(Qt.GlobalColor.yellow)  # 하이라이트
                self.table.setItem(i, j, item)
            elif i == j:
                # Diagonal: 빈 칸 + 회색 배경
                item = QTableWidgetItem("")
                item.setBackground(Qt.GlobalColor.lightGray)
                self.table.setItem(i, j, item)
            else:
                # Lower triangle: 빈 칸
                item = QTableWidgetItem("")
                self.table.setItem(i, j, item)
```

### 하이라이트 개선

이전: 마지막 행/열 하이라이트 (잘못된 위치)
```python
if i == n-1 or j == n-1:  # 항상 마지막
    item.setBackground(Qt.GlobalColor.yellow)
```

현재: 병합된 클러스터 하이라이트 (올바른 위치)
```python
# 첫 번째 tuple label 찾기 (병합된 것)
merged_idx = -1
for idx, label in enumerate(labels):
    if isinstance(label, (tuple, list)):
        merged_idx = idx
        break

# 해당 행/열 하이라이트
if merged_idx >= 0 and (i == merged_idx or j == merged_idx):
    item.setBackground(Qt.GlobalColor.yellow)
```

## 테스트 결과

```bash
$ python test_clustering_steps.py

Step 0: [J, T, Y, N, O, Q]           ✓ 원본 순서

Step 1: [J+T, Y, N, O, Q]            ✓ J의 위치에 J+T
  Labels 순서 유지!

Step 2: [J+T, Y, N, O+Q]             ✓ O의 위치에 O+Q
  Labels 순서 유지!

Step 3: [J+T+Y, N, O+Q]              ✓ J+T의 위치에 J+T+Y
  병합이 누적됨!

Step 4: [J+T+Y, N+O+Q]               ✓ N의 위치에 N+O+Q
  순서 완벽!

Step 5: [J+N+O+Q+T+Y]                ✓ 최종 병합
  모든 순서 유지!
```

## 사용자 경험 개선

### Before
```
Matrix:
       J    T    Y    N    O    Q
J    1.0  0.9  0.8  ...
T    0.9  1.0  0.8  ...  ← 중복
Y    0.8  0.8  1.0  ...  ← 중복
...

Step 1: [Y, N, O, Q, J+T]  ← 순서 뒤바뀜
```

- ❌ 불필요한 정보 (대각선, 중복)
- ❌ 순서가 계속 바뀜
- ❌ 병합된 클러스터 위치 불명확

### After
```
Matrix (upper triangle only):
       J    T    Y    N    O    Q
J      -   0.9  0.8  ...
T          -    0.8  ...
Y               -    ...
...

Step 1: [J+T, Y, N, O, Q]  ← 순서 유지
```

- ✅ 필요한 정보만 표시
- ✅ 순서 일관성 유지
- ✅ 병합된 클러스터 노란색 하이라이트

## 장점

### 1. 인지 부하 감소
- 대칭 정보 중복 제거
- 시각적으로 더 깔끔
- Upper triangle만 보면 됨

### 2. 순서 일관성
- 원본 순서가 최대한 유지
- J는 항상 앞쪽
- Q는 항상 뒤쪽
- 병합은 앞쪽 클러스터 위치에

### 3. 추적 용이성
- 어떤 클러스터가 어디서 병합되는지 명확
- Label 위치가 안정적
- 하이라이트로 변경사항 강조

## 비교 예시

### 원본 데이터
```
Labels: [J, T, Y, N, O, Q]
```

### Before (문제)
```
Step 1: [Y, N, O, Q, J+T]     ← J, T 사라짐, J+T 맨 뒤
Step 2: [Y, N, J+T, O+Q]      ← O, Q 사라짐, O+Q 중간
Step 3: [N, O+Q, J+T+Y]       ← 순서 완전히 뒤바뀜
```

추적 어려움:
- J가 어디 갔지?
- T는?
- 순서를 계속 찾아야 함

### After (해결)
```
Step 1: [J+T, Y, N, O, Q]     ← J 자리에 J+T
Step 2: [J+T, Y, N, O+Q]      ← O 자리에 O+Q
Step 3: [J+T+Y, N, O+Q]       ← J+T 자리에 J+T+Y
```

추적 쉬움:
- J+T는 항상 앞쪽
- O+Q는 항상 뒤쪽
- 순서가 예측 가능

## 구현 세부사항

### Label 순서 보존 알고리즘

```python
old_to_new_idx = {}  # 인덱스 매핑
new_idx = 0

for old_idx in range(n):
    if old_idx == idx_i:
        # 병합 클러스터를 idx_i 위치에
        new_labels.append(merged_cluster)
        old_to_new_idx[old_idx] = new_idx
        new_idx += 1
    elif old_idx == idx_j:
        # idx_j는 제거 (skip)
        continue
    else:
        # 나머지는 순서대로
        new_labels.append(labels[old_idx])
        old_to_new_idx[old_idx] = new_idx
        new_idx += 1
```

### Matrix 값 매핑

```python
for old_i in range(n):
    if old_i == idx_j:
        continue  # 제거된 행 skip

    for old_j in range(n):
        if old_j == idx_j:
            continue  # 제거된 열 skip

        if old_i == idx_i:
            # 병합 클러스터 행: 평균 계산
            avg = (matrix[idx_i, old_j] + matrix[idx_j, old_j]) / 2
            new_matrix[new_i, new_j] = avg
        elif old_j == idx_i:
            # 병합 클러스터 열: 평균 계산
            avg = (matrix[old_i, idx_i] + matrix[old_i, idx_j]) / 2
            new_matrix[new_i, new_j] = avg
        else:
            # 그 외: 복사
            new_matrix[new_i, new_j] = matrix[old_i, old_j]
```

## 결론

두 가지 개선으로:
1. **순서 유지**: 병합이 앞쪽 위치에서 일어남
2. **정보 간소화**: Upper triangle만 표시

결과:
- ✅ 추적하기 쉬움
- ✅ 시각적으로 깔끔
- ✅ 인지 부하 감소
- ✅ 교육적 가치 증가

클러스터링 과정을 더 쉽게 이해할 수 있습니다!
