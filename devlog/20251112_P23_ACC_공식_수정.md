# P23: ACC 공식 수정 - Subordinate/Inclusive Similarity 역할 수정

**날짜**: 2025-11-12
**작업자**: Claude
**관련 파일**: acc_core_new.py

## 문제 발견

사용자가 ACC 생성 시 radius가 1~2 사이로 나오는 것을 보고 논문(Text.docx)의 공식과 일치하는지 확인 요청

## 논문 분석 (Text.docx - Section 2.3)

**두 가지 유사도 점수의 의미:**

1. **First similarity score (Subordinate dataset)**
   - **Closest possible affinity** (가장 가까운 유사도)
   - 각 시간 구간의 subordinate dataset에서 계산
   - 예: Caradoc 시기의 trilobite 데이터

2. **Second similarity score (Inclusive dataset)**
   - **Farthest possible affinity** (가장 먼 유사도)
   - 전체 기간을 포함하는 inclusive dataset에서 계산
   - 예: 전체 Ordovician 시기의 trilobite 데이터

**논문의 공식:**

```
Farthest possible affinity (Diameter):
  d = 1 cm / inclusive_similarity

Closest possible affinity (Angle):
  θ = 180° × (1 - subordinate_similarity)
```

**공식의 의미:**
- Inclusive similarity가 높을수록 → diameter가 작아짐 → 전체적으로 가까운 클러스터
- Subordinate similarity가 높을수록 → angle이 작아짐 → 원 위에서 가까이 배치

## 발견된 문제

### 코드의 잘못된 구현 (수정 전)

```python
# place_first_two_areas 함수 (Line 116, 127)
radius = unit / sub_sim                # ❌ subordinate로 radius 계산
angle = 180.0 * (1.0 - inc_sim)        # ❌ inclusive로 angle 계산
```

**문제:**
- Subordinate와 Inclusive의 역할이 완전히 바뀌어 있음!
- Subordinate similarity → radius (잘못됨)
- Inclusive similarity → angle (잘못됨)

**올바른 공식:**
- Inclusive similarity → diameter/radius (farthest possible affinity)
- Subordinate similarity → angle (closest possible affinity)

## 수정 내용

### 1. place_first_two_areas 함수 (Line 90-124)

**수정 전:**
```python
def place_first_two_areas(area1, area2, sub_sim, inc_sim, unit=1.0):
    """
    Args:
        sub_sim: subordinate similarity (determines radius)  # ❌
        inc_sim: inclusive similarity (determines angle)      # ❌
    """
    # Calculate radius based on subordinate similarity
    if sub_sim > 0:
        radius = unit / sub_sim    # ❌
    else:
        radius = unit * 100

    # Calculate angle based on inclusive similarity
    angle = 180.0 * (1.0 - inc_sim)  # ❌
```

**수정 후:**
```python
def place_first_two_areas(area1, area2, sub_sim, inc_sim, unit=1.0):
    """
    Args:
        sub_sim: subordinate similarity (determines angle - closest possible affinity)  # ✓
        inc_sim: inclusive similarity (determines diameter - farthest possible affinity) # ✓
    """
    # Calculate diameter based on INCLUSIVE similarity (farthest possible affinity)
    # Formula from paper: d = unit / inc_sim
    if inc_sim > 0:
        diameter = unit / inc_sim  # ✓
    else:
        diameter = unit * 100

    radius = diameter / 2.0

    # Calculate angle based on SUBORDINATE similarity (closest possible affinity)
    # Formula from paper: θ = 180° × (1 - sub_sim)
    angle = 180.0 * (1.0 - sub_sim)  # ✓
```

### 2. add_area_to_cluster 함수 (Line 344-407)

**수정 사항:**
- `sub_matrix` 파라미터 추가
- Subordinate similarity로 best member 찾기
- Subordinate similarity로 angle 계산

**수정 전:**
```python
def add_area_to_cluster(cluster, new_area, inc_matrix):
    # Find which member has highest similarity to new area
    for member in cluster['members']:
        sim = get_similarity(inc_matrix, member, new_area)  # ❌ inclusive 사용

    # Angle from best_member is based on inclusive similarity
    angle_from_member = 180.0 * (1.0 - best_sim)  # ❌
```

**수정 후:**
```python
def add_area_to_cluster(cluster, new_area, sub_matrix, inc_matrix):
    # Find which member has highest similarity to new area
    # Use SUBORDINATE similarity (closest possible affinity) for positioning
    best_sub_sim = -1.0

    for member in cluster['members']:
        sub_sim = get_similarity(sub_matrix, member, new_area)  # ✓ subordinate 사용
        if sub_sim and sub_sim > best_sub_sim:
            best_sub_sim = sub_sim
            best_member = member

    # Angle from best_member is based on SUBORDINATE similarity
    angle_from_member = 180.0 * (1.0 - best_sub_sim)  # ✓
```

**호출 부분 수정 (Line 714):**
```python
# 수정 전
updated_cluster = add_area_to_cluster(cluster, area, current_inc)  # ❌

# 수정 후
updated_cluster = add_area_to_cluster(cluster, area, current_sub, current_inc)  # ✓
```

### 3. merge_two_clusters 함수 (Line 410-475)

**수정 사항:**
- `sub_matrix` 파라미터 추가
- Subordinate similarity로 best pair 찾기
- Subordinate similarity로 alignment angle 계산

**수정 전:**
```python
def merge_two_clusters(c1, c2, inc_matrix, unit=1.0):
    # Find the most similar pair between the two clusters
    for m1 in c1['members']:
        for m2 in c2['members']:
            sim = get_similarity(inc_matrix, m1, m2)  # ❌ inclusive 사용

    # Calculate angle between the two alignment members
    alignment_angle = 180.0 * (1.0 - best_sim)  # ❌

    merged = {
        'sub_sim': best_sim,
        'inc_sim': best_sim,
    }
```

**수정 후:**
```python
def merge_two_clusters(c1, c2, sub_matrix, inc_matrix, unit=1.0):
    # Find the most similar pair between the two clusters
    # Use SUBORDINATE similarity (closest possible affinity) for positioning
    best_sub_sim = -1.0
    best_inc_sim = -1.0

    for m1 in c1['members']:
        for m2 in c2['members']:
            sub_sim = get_similarity(sub_matrix, m1, m2)  # ✓ subordinate 사용
            if sub_sim and sub_sim > best_sub_sim:
                best_sub_sim = sub_sim
                best_pair = (m1, m2)
                # Also get inclusive similarity for this pair
                inc_sim = get_similarity(inc_matrix, m1, m2)
                best_inc_sim = inc_sim if inc_sim else sub_sim

    # Calculate angle between the two alignment members based on SUBORDINATE similarity
    alignment_angle = 180.0 * (1.0 - best_sub_sim)  # ✓

    merged = {
        'sub_sim': best_sub_sim,  # Subordinate similarity (closest affinity)
        'inc_sim': best_inc_sim,  # Inclusive similarity (farthest affinity)
    }
```

**호출 부분 수정 (Line 762):**
```python
# 수정 前
merged_cluster = merge_two_clusters(c1, c2, current_inc, unit=1.0)  # ❌

# 수정 後
merged_cluster = merge_two_clusters(c1, c2, current_sub, current_inc, unit=1.0)  # ✓
```

## 수정 영향

### 계산 결과의 변화

**예시: similarity 값이 다음과 같을 때**
- Subordinate similarity = 0.90 (Caradoc 시기)
- Inclusive similarity = 0.80 (전체 Ordovician)
- Unit = 1.0

**수정 전 (잘못됨):**
```
radius = 1.0 / 0.90 ≈ 1.11
angle = 180° × (1 - 0.80) = 36°
```

**수정 후 (올바름):**
```
diameter = 1.0 / 0.80 = 1.25
radius = 1.25 / 2 = 0.625
angle = 180° × (1 - 0.90) = 18°
```

**차이점:**
- Radius: 더 작아짐 (inclusive similarity가 subordinate보다 낮기 때문)
- Angle: 더 작아짐 (subordinate similarity가 높기 때문)

### 의미의 변화

**수정 전:**
- Subordinate similarity가 높으면 → radius가 작음 → 원이 작음
- Inclusive similarity가 높으면 → angle이 작음 → 가깝게 배치

**수정 후 (논문과 일치):**
- Inclusive similarity가 높으면 → diameter가 작음 → 원이 작음 (전체적으로 tight한 클러스터)
- Subordinate similarity가 높으면 → angle이 작음 → 가깝게 배치 (시간대별로 close)

## 논문의 개념 정리

**왜 두 가지 similarity를 사용하는가?**

1. **Subordinate dataset (각 시간대)**:
   - 특정 시간대의 생물 분포
   - 그 시간대에서의 지역 간 유사도 → "그 시기에 얼마나 가까웠나?"
   - **Closest possible affinity** (가장 가까운 관계)

2. **Inclusive dataset (전체 기간)**:
   - 전체 시간대를 합친 생물 분포
   - 전 시기를 통틀어 본 지역 간 유사도 → "전체적으로 얼마나 가까웠나?"
   - **Farthest possible affinity** (가장 먼 관계)

**시각화에서의 의미:**
- **원의 크기** (diameter): 전체 기간 동안의 평균적 거리 (inclusive)
- **원 위의 각도** (angle): 특정 시기의 상대적 거리 (subordinate)

## 테스트 결과 예상

수정 후 예상되는 변화:
1. ✅ Radius/diameter 값이 inclusive similarity에 반비례
2. ✅ Angle 값이 subordinate similarity에 반비례
3. ✅ 논문의 Figure 4, 5와 유사한 패턴
4. ✅ Show Log에서 올바른 공식 적용 확인 가능

## 참고 문헌

**Text.docx - Section 2.3: Farthest and closest possible affinity**

> "The first similarity index score is considered to represent the closest possible affinity between two areas and the second the farthest possible affinity. The farthest possible affinity is expressed as a circle with a diameter (d), calculated by an equation, d = 1cm/score. The reciprocal of the score is taken because the higher the similarity score of a cluster is, the biogeographically closer the constituting areas are, and thus, the areas should be placed along a circle with a smaller diameter. The diameter, "1 cm" in the equation can be any length used for the entire procedure. The closest possible affinity is expressed as an angle (θ) along the circle, calculated by an equation, θ = 180° × (1-score). The subtraction is taken because the areas of a cluster with a higher similarity score should be positioned closer, and thus, at a smaller angle along the circle."

## 교훈

1. **논문의 공식을 정확히 따라야 함**: 변수의 역할을 혼동하면 전혀 다른 결과가 나옴
2. **개념적 이해 중요**: Subordinate vs Inclusive의 의미를 이해해야 올바른 구현 가능
3. **단위 검증**: radius 값의 범위가 이상하다는 사용자의 직관이 버그 발견으로 이어짐
4. **문서 참조의 중요성**: 구현 중에 주석으로 가정을 적었지만, 논문을 다시 확인하니 반대였음

## 다음 단계

1. ✅ ACC 공식 수정 완료
2. ⏭️ GUI에서 새로운 공식으로 ACC 생성 테스트
3. ⏭️ 결과가 논문의 Figure 4, 5와 유사한지 확인
4. ⏭️ Show Log로 계산 과정 검증
5. ⏭️ 필요시 visualization scaling 조정
