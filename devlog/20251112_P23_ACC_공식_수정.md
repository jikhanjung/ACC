# P23: ACC 공식 수정 - Local/Global Similarity 역할 수정

**날짜**: 2025-11-12
**작업자**: Claude
**관련 파일**: acc_core_new.py

## 문제 발견

사용자가 ACC 생성 시 radius가 1~2 사이로 나오는 것을 보고 논문(Text.docx)의 공식과 일치하는지 확인 요청

## 논문 분석 (Text.docx - Section 2.3)

**두 가지 유사도 점수의 의미:**

1. **First similarity score (Local dataset)**
   - **Closest possible affinity** (가장 가까운 유사도)
   - 각 시간 구간의 local dataset에서 계산
   - 예: Caradoc 시기의 trilobite 데이터

2. **Second similarity score (Global dataset)**
   - **Farthest possible affinity** (가장 먼 유사도)
   - 전체 기간을 포함하는 global dataset에서 계산
   - 예: 전체 Ordovician 시기의 trilobite 데이터

**논문의 공식:**

```
Farthest possible affinity (Diameter):
  d = 1 cm / global_similarity

Closest possible affinity (Angle):
  θ = 180° × (1 - local_similarity)
```

**공식의 의미:**
- Global similarity가 높을수록 → diameter가 작아짐 → 전체적으로 가까운 클러스터
- Local similarity가 높을수록 → angle이 작아짐 → 원 위에서 가까이 배치

## 발견된 문제

### 코드의 잘못된 구현 (수정 전)

```python
# place_first_two_areas 함수 (Line 116, 127)
radius = unit / local_sim                # ❌ local로 radius 계산
angle = 180.0 * (1.0 - global_sim)        # ❌ global로 angle 계산
```

**문제:**
- Local와 Global의 역할이 완전히 바뀌어 있음!
- Local similarity → radius (잘못됨)
- Global similarity → angle (잘못됨)

**올바른 공식:**
- Global similarity → diameter/radius (farthest possible affinity)
- Local similarity → angle (closest possible affinity)

## 수정 내용

### 1. place_first_two_areas 함수 (Line 90-124)

**수정 전:**
```python
def place_first_two_areas(area1, area2, local_sim, global_sim, unit=1.0):
    """
    Args:
        local_sim: local similarity (determines radius)  # ❌
        global_sim: global similarity (determines angle)      # ❌
    """
    # Calculate radius based on local similarity
    if local_sim > 0:
        radius = unit / local_sim    # ❌
    else:
        radius = unit * 100

    # Calculate angle based on global similarity
    angle = 180.0 * (1.0 - global_sim)  # ❌
```

**수정 후:**
```python
def place_first_two_areas(area1, area2, local_sim, global_sim, unit=1.0):
    """
    Args:
        local_sim: local similarity (determines angle - closest possible affinity)  # ✓
        global_sim: global similarity (determines diameter - farthest possible affinity) # ✓
    """
    # Calculate diameter based on INCLUSIVE similarity (farthest possible affinity)
    # Formula from paper: d = unit / global_sim
    if global_sim > 0:
        diameter = unit / global_sim  # ✓
    else:
        diameter = unit * 100

    radius = diameter / 2.0

    # Calculate angle based on SUBORDINATE similarity (closest possible affinity)
    # Formula from paper: θ = 180° × (1 - local_sim)
    angle = 180.0 * (1.0 - local_sim)  # ✓
```

### 2. add_area_to_cluster 함수 (Line 344-407)

**수정 사항:**
- `local_matrix` 파라미터 추가
- Local similarity로 best member 찾기
- Local similarity로 angle 계산

**수정 전:**
```python
def add_area_to_cluster(cluster, new_area, global_matrix):
    # Find which member has highest similarity to new area
    for member in cluster['members']:
        sim = get_similarity(global_matrix, member, new_area)  # ❌ global 사용

    # Angle from best_member is based on global similarity
    angle_from_member = 180.0 * (1.0 - best_sim)  # ❌
```

**수정 후:**
```python
def add_area_to_cluster(cluster, new_area, local_matrix, global_matrix):
    # Find which member has highest similarity to new area
    # Use SUBORDINATE similarity (closest possible affinity) for positioning
    best_local_sim = -1.0

    for member in cluster['members']:
        local_sim = get_similarity(local_matrix, member, new_area)  # ✓ local 사용
        if local_sim and local_sim > best_local_sim:
            best_local_sim = local_sim
            best_member = member

    # Angle from best_member is based on SUBORDINATE similarity
    angle_from_member = 180.0 * (1.0 - best_local_sim)  # ✓
```

**호출 부분 수정 (Line 714):**
```python
# 수정 전
updated_cluster = add_area_to_cluster(cluster, area, current_inc)  # ❌

# 수정 후
updated_cluster = add_area_to_cluster(cluster, area, current_sub, current_inc)  # ✓
```

### 3. merge_two_clusters 함수 (Line 410-475)

**수정 사항:**
- `local_matrix` 파라미터 추가
- Local similarity로 best pair 찾기
- Local similarity로 alignment angle 계산

**수정 전:**
```python
def merge_two_clusters(c1, c2, global_matrix, unit=1.0):
    # Find the most similar pair between the two clusters
    for m1 in c1['members']:
        for m2 in c2['members']:
            sim = get_similarity(global_matrix, m1, m2)  # ❌ global 사용

    # Calculate angle between the two alignment members
    alignment_angle = 180.0 * (1.0 - best_sim)  # ❌

    merged = {
        'local_sim': best_sim,
        'global_sim': best_sim,
    }
```

**수정 후:**
```python
def merge_two_clusters(c1, c2, local_matrix, global_matrix, unit=1.0):
    # Find the most similar pair between the two clusters
    # Use SUBORDINATE similarity (closest possible affinity) for positioning
    best_local_sim = -1.0
    best_global_sim = -1.0

    for m1 in c1['members']:
        for m2 in c2['members']:
            local_sim = get_similarity(local_matrix, m1, m2)  # ✓ local 사용
            if local_sim and local_sim > best_local_sim:
                best_local_sim = local_sim
                best_pair = (m1, m2)
                # Also get global similarity for this pair
                global_sim = get_similarity(global_matrix, m1, m2)
                best_global_sim = global_sim if global_sim else local_sim

    # Calculate angle between the two alignment members based on SUBORDINATE similarity
    alignment_angle = 180.0 * (1.0 - best_local_sim)  # ✓

    merged = {
        'local_sim': best_local_sim,  # Local similarity (closest affinity)
        'global_sim': best_global_sim,  # Global similarity (farthest affinity)
    }
```

**호출 부분 수정 (Line 762):**
```python
# 수정 前
merged_cluster = merge_two_clusters(c1, c2, current_inc, unit=1.0)  # ❌

# 수정 後
merged_cluster = merge_two_clusters(c1, c2, current_sub, current_inc, unit=1.0)  # ✓
```

## 수정 영향

### 계산 결과의 변화

**예시: similarity 값이 다음과 같을 때**
- Local similarity = 0.90 (Caradoc 시기)
- Global similarity = 0.80 (전체 Ordovician)
- Unit = 1.0

**수정 전 (잘못됨):**
```
radius = 1.0 / 0.90 ≈ 1.11
angle = 180° × (1 - 0.80) = 36°
```

**수정 후 (올바름):**
```
diameter = 1.0 / 0.80 = 1.25
radius = 1.25 / 2 = 0.625
angle = 180° × (1 - 0.90) = 18°
```

**차이점:**
- Radius: 더 작아짐 (global similarity가 local보다 낮기 때문)
- Angle: 더 작아짐 (local similarity가 높기 때문)

### 의미의 변화

**수정 전:**
- Local similarity가 높으면 → radius가 작음 → 원이 작음
- Global similarity가 높으면 → angle이 작음 → 가깝게 배치

**수정 후 (논문과 일치):**
- Global similarity가 높으면 → diameter가 작음 → 원이 작음 (전체적으로 tight한 클러스터)
- Local similarity가 높으면 → angle이 작음 → 가깝게 배치 (시간대별로 close)

## 논문의 개념 정리

**왜 두 가지 similarity를 사용하는가?**

1. **Local dataset (각 시간대)**:
   - 특정 시간대의 생물 분포
   - 그 시간대에서의 지역 간 유사도 → "그 시기에 얼마나 가까웠나?"
   - **Closest possible affinity** (가장 가까운 관계)

2. **Global dataset (전체 기간)**:
   - 전체 시간대를 합친 생물 분포
   - 전 시기를 통틀어 본 지역 간 유사도 → "전체적으로 얼마나 가까웠나?"
   - **Farthest possible affinity** (가장 먼 관계)

**시각화에서의 의미:**
- **원의 크기** (diameter): 전체 기간 동안의 평균적 거리 (global)
- **원 위의 각도** (angle): 특정 시기의 상대적 거리 (local)

## 테스트 결과 예상

수정 후 예상되는 변화:
1. ✅ Radius/diameter 값이 global similarity에 반비례
2. ✅ Angle 값이 local similarity에 반비례
3. ✅ 논문의 Figure 4, 5와 유사한 패턴
4. ✅ Show Log에서 올바른 공식 적용 확인 가능

## 참고 문헌

**Text.docx - Section 2.3: Farthest and closest possible affinity**

> "The first similarity index score is considered to represent the closest possible affinity between two areas and the second the farthest possible affinity. The farthest possible affinity is expressed as a circle with a diameter (d), calculated by an equation, d = 1cm/score. The reciprocal of the score is taken because the higher the similarity score of a cluster is, the biogeographically closer the constituting areas are, and thus, the areas should be placed along a circle with a smaller diameter. The diameter, "1 cm" in the equation can be any length used for the entire procedure. The closest possible affinity is expressed as an angle (θ) along the circle, calculated by an equation, θ = 180° × (1-score). The subtraction is taken because the areas of a cluster with a higher similarity score should be positioned closer, and thus, at a smaller angle along the circle."

## 교훈

1. **논문의 공식을 정확히 따라야 함**: 변수의 역할을 혼동하면 전혀 다른 결과가 나옴
2. **개념적 이해 중요**: Local vs Global의 의미를 이해해야 올바른 구현 가능
3. **단위 검증**: radius 값의 범위가 이상하다는 사용자의 직관이 버그 발견으로 이어짐
4. **문서 참조의 중요성**: 구현 중에 주석으로 가정을 적었지만, 논문을 다시 확인하니 반대였음

## 다음 단계

1. ✅ ACC 공식 수정 완료
2. ⏭️ GUI에서 새로운 공식으로 ACC 생성 테스트
3. ⏭️ 결과가 논문의 Figure 4, 5와 유사한지 확인
4. ⏭️ Show Log로 계산 과정 검증
5. ⏭️ 필요시 visualization scaling 조정
