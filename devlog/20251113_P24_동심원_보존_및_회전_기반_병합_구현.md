# P24: 동심원 보존 및 회전 기반 병합 구현 (2025-11-13)

## 개요

ACC 알고리즘의 핵심 제약사항인 **동심원 보존(Concentric Circles Preservation)**을 구현하고, 논문의 수식을 정확하게 반영하도록 알고리즘을 수정했습니다.

## 구현된 주요 기능

### 1. Linkage Similarity 계산 수정

**문제점:**
- 클러스터 {A, B}와 새 영역 C의 similarity를 계산할 때, 모든 쌍의 평균 `(A-B + A-C + B-C) / 3`을 계산하고 있었음
- 계층적 클러스터링의 **Average Linkage** 개념과 맞지 않음

**수정사항:**
- `add_area_to_cluster()` 함수에서 **클러스터-영역 간 linkage similarity** 계산
- 클러스터의 각 멤버와 새 영역 간 similarity의 평균: `(A-C + B-C) / 2`
- `merge_two_clusters()` 함수에서 **클러스터-클러스터 간 linkage similarity** 계산
- 두 클러스터의 모든 멤버 쌍 간 similarity의 평균

**파일:** `acc_core_new.py:424-451`, `acc_core_new.py:545-571`

### 2. 동심원 보존 - 영역 추가 시

**문제점:**
- 새 영역을 추가할 때 기존 점들을 새 radius로 scaling 하고 있었음
- 예: A, B가 radius 1.0에 있을 때, C를 추가하면서 A, B까지 radius 1.429로 이동
- 동심원 구조가 파괴됨

**수정사항:**
- `add_area_to_cluster()` 함수에서 **기존 점들의 위치를 절대 변경하지 않음**
- 새 영역만 새로운 (더 큰) 동심원 위에 배치
- 결과: A, B는 작은 동심원(r=1.0), C는 큰 동심원(r=1.429)에 각각 위치

**파일:** `acc_core_new.py:466-478`

```python
# IMPORTANT: Preserve concentric circles structure
# DO NOT scale existing points - they stay on their original circles
# Only the new area is placed on the new (outer) circle
new_cluster = {
    'members': new_members,
    'center': cluster['center'],
    'radius': new_radius,
    'diameter': new_diameter,
    'angle': new_angle,
    'local_sim': new_local_sim,
    'global_sim': new_global_sim,
    'points': dict(cluster['points']),  # Keep existing points as-is
    ...
}
```

### 3. 회전 기반 클러스터 병합

**문제점:**
- 두 클러스터를 병합할 때 상대 위치 이동(translation)을 사용
- 병합 후 일부 점들이 원래 동심원에서 벗어남
- 예: J, T가 radius 0.568에 있다가 O, Q와 병합 후 다른 radius로 이동

**수정사항:**
- `merge_two_clusters()` 함수를 완전히 재설계
- **원점(0, 0)을 중심으로 한 회전(rotation)만 사용**
- 각 점의 radius는 절대 변경되지 않음
- 정렬(alignment)을 위해 두 클러스터를 각각 회전시킴

**파일:** `acc_core_new.py:590-650`

**알고리즘:**
1. 두 클러스터에서 가장 유사한 멤버 쌍(m1, m2) 찾기
2. m1과 m2가 마주보도록 목표 각도 계산
3. 각 클러스터의 모든 점을 회전
4. **각 점의 radius는 유지, 각도만 변경**

```python
# Rotate all members, keep radius unchanged
for member in c1['members']:
    old_pos = c1['points'][member]
    old_angle = math.degrees(math.atan2(old_pos[1], old_pos[0]))
    old_radius = math.sqrt(old_pos[0]**2 + old_pos[1]**2)

    # Apply rotation, keep radius unchanged
    new_angle = old_angle + rotation1
    merged['points'][member] = pol2cart(old_radius, new_angle)
```

### 4. 중첩 구조 표시

**수정사항:**
- 클러스터의 계층 구조를 `[[A, B], C]` 형태로 표시
- `structure` 필드 추가 및 `format_cluster_structure()` 함수 구현
- 로그와 GUI에서 중첩 구조 표시

**파일:** `acc_core_new.py:123-131`, `acc_core_new.py:478`, `acc_core_new.py:651`

### 5. GUI 동심원 시각화

**수정사항:**
- 모든 고유한 radius를 수집하여 각각 동심원으로 표시
- 각 동심원을 무지개 색상으로 구분
- `plot_acc_step()`, `plot_acc_result()` 함수에서 동심원 그리기

**파일:** `acc_gui.py:1238-1264`, `acc_gui.py:1351-1378`

**알고리즘:**
1. 모든 클러스터의 모든 점에서 radius 계산 (원점에서 거리)
2. 고유한 radius 값 수집
3. 각 radius에 대해 동심원 그리기

```python
for cluster in clusters:
    points = cluster.get("points", {})
    for member, (x, y) in points.items():
        # Calculate actual radius from origin (0, 0)
        actual_radius = math.sqrt(x**2 + y**2)
        all_radii.add(round(actual_radius, 3))
```

## 검증 및 테스트

### 테스트 파일 생성

1. **test_linkage_abc.py**: Linkage similarity 계산 검증
2. **test_concentric.py**: 영역 추가 시 동심원 보존 검증
3. **test_merge_radii.py**: 병합 시 radius 보존 검증
4. **visualize_concentric_circles.py**: 단계별 동심원 시각화
5. **analyze_levels.py**: Dendrogram level별 radius 분석

### 검증 결과

**Radius 보존 확인:**
```
J: Steps 0-4, radius = 0.568 ✅
T: Steps 0-4, radius = 0.568 ✅
O: Steps 1-4, radius = 0.602 ✅
Q: Steps 1-4, radius = 0.602 ✅
Y: Steps 2-4, radius = 0.617 ✅
N: Steps 3-4, radius = 0.725 ✅
```

**생성된 동심원 (4개):**
- Circle 1 (r=0.568): J, T
- Circle 2 (r=0.602): O, Q
- Circle 3 (r=0.617): Y
- Circle 4 (r=0.725): N

## 현재 구현 상태

### 구현 완료
- ✅ Linkage similarity를 사용한 클러스터 similarity 계산
- ✅ 동심원 구조 보존 (영역 추가 시)
- ✅ 회전 기반 클러스터 병합 (radius 유지)
- ✅ 중첩 계층 구조 표시
- ✅ GUI에서 모든 동심원 시각화
- ✅ 단계별 ACC 알고리즘 시각화
- ✅ PyQt5 기반 GUI

### 알려진 제한사항

**최종 병합 level의 동심원 미표시:**
- 현재: 점이 배치된 동심원만 표시 (4개)
- 이론적: 모든 merge level의 동심원 표시 필요 (5개)
- Level 5 (최종 병합, r=1.415)의 동심원이 그려지지 않음
- 이유: 최종 병합은 기존 점들을 회전만 시키고 새 점을 추가하지 않음

**해결 방안 (향후 개선):**
- Dendrogram의 모든 merge level을 먼저 분석
- 각 level마다 동심원 생성 (점이 없어도)
- 각 멤버를 해당 level의 동심원에 배치
- 옵션으로 선택 가능하도록 구현 예정

## 핵심 공식 (논문 기반)

### Diameter (Global Similarity)
```
d = unit / sim_global
```
- 높은 global similarity → 작은 diameter (밀집된 클러스터)

### Angle (Local Similarity)
```
θ = 180° × (1 - sim_local)
```
- 높은 local similarity → 작은 angle (가까운 배치)

### Radius
```
r = d / 2
```

## 파일 변경사항

### 핵심 알고리즘
- `acc_core_new.py`: Linkage similarity, 동심원 보존, 회전 기반 병합

### GUI
- `acc_gui.py`: 동심원 시각화, NameError 수정

### 테스트/분석
- `test_linkage_abc.py`: 새로 생성
- `test_concentric.py`: 새로 생성
- `test_merge_radii.py`: 새로 생성
- `visualize_concentric_circles.py`: 새로 생성
- `analyze_levels.py`: 새로 생성

## 결론

ACC 알고리즘의 핵심 특성인 **동심원 보존**이 완전히 구현되었습니다. 각 점은 한 번 배치되면 절대 자신의 동심원을 벗어나지 않으며, 클러스터 병합 시 회전만 적용됩니다. 이는 논문의 기하학적 제약사항을 정확하게 반영한 구현입니다.

향후 개선사항으로 모든 dendrogram level의 동심원을 표시하는 옵션을 추가할 예정입니다.
