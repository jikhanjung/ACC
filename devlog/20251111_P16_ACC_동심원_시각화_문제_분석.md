# 20251111 P16: ACC 동심원 시각화 문제 분석

## 문제 요약

**현재**: 모든 area가 **하나의 원** 위에 표시됨
**기대**: 여러 개의 **동심원(concentric circles)**에 cluster별로 분산 표시

## 근본 원인

### 현재 구조 분석

#### 1. acc_core.py - build_acc() (342-367행)

```python
def build_acc(sub_dendro, inc_dendro, inc_matrix, unit=1.0):
    # 1) 모든 클러스터 추출
    clusters = extract_clusters_from_dendro(sub_dendro)

    # 2) 각 클러스터에 sim_inc, diameter, theta 할당
    decorate_clusters(clusters, inc_dendro, inc_matrix, unit=unit)

    # 3) 유사도 순 정렬
    clusters.sort(key=lambda c: c["sim_sub"], reverse=True)

    # 4) 첫 번째 클러스터 배치
    base = place_first_cluster(clusters[0])

    # 5) 나머지 클러스터를 하나씩 병합 ⚠️
    for c in clusters[1:]:
        if ...:
            base = add_area_to_cluster(base, c, inc_matrix)
        else:
            base = merge_two_clusters(base, c, inc_matrix)

    # ⚠️ 최종 병합 결과 하나만 반환!
    return base
```

**문제점:**
- 각 클러스터가 고유한 `diameter` 값을 가지고 있음
- 하지만 병합 과정에서 **모든 클러스터가 하나로 합쳐짐**
- 최종적으로 **하나의 dict**만 반환
- 중간 클러스터들의 diameter 정보 손실

#### 2. acc_gui.py - plot_acc_result() (619-668행)

```python
def plot_acc_result(self, acc_result):
    # 단일 결과에서 데이터 추출
    center = acc_result.get("center", (0, 0))  # 하나의 중심
    diameter = acc_result.get("diameter", 1.0)  # 하나의 지름
    radius = diameter / 2.0
    points = acc_result.get("points", {})

    # ⚠️ 원 하나만 그림!
    circle = plt.Circle(center, radius, fill=False,
                       edgecolor='blue', linewidth=2)
    ax.add_patch(circle)

    # 모든 점을 같은 원 위에 표시
    for member, (x, y) in points.items():
        ax.plot(x, y, 'o', markersize=10, ...)
```

**문제점:**
- 단일 `diameter` 값만 받음
- **하나의 원**만 그림
- 각 클러스터의 고유한 diameter 정보 없음

## Text.docx의 핵심 개념

### ACC Algorithm의 본질

```
각 클러스터는 두 개의 similarity 값을 가짐:
1. sim_sub (subordinate): 가장 가까운 affinity → angle (θ)
2. sim_inc (inclusive): 가장 먼 affinity → diameter (d)

Geometric Conversion:
- Diameter: d = unit / sim_inc
- Angle: θ = 180° × (1 - sim_sub)

⚠️ 각 클러스터는 고유한 diameter를 가진 원을 형성!
```

### 예시

```
Cluster 1: {J, T}
  - sim_sub = 0.90 → θ = 18°
  - sim_inc = 0.88 → d₁ = 1.0 / 0.88 = 1.136

Cluster 2: {O, Q}
  - sim_sub = 0.85 → θ = 27°
  - sim_inc = 0.83 → d₂ = 1.0 / 0.83 = 1.205

Cluster 3: {J, T, Y}
  - sim_sub = 0.80 → θ = 36°
  - sim_inc = 0.78 → d₃ = 1.0 / 0.78 = 1.282

결과:
- 3개의 동심원 (d₁, d₂, d₃)
- 각 원 위에 해당 cluster의 members 배치
```

### 시각적 구조

```
          Y
          |
    J─────+─────T    ← Cluster 3 (d₃ = 1.282)


       J─────T        ← Cluster 1 (d₁ = 1.136)


       O─────Q        ← Cluster 2 (d₂ = 1.205)


       +              ← Origin (0, 0)

각 cluster가 자기만의 원 위에 존재!
```

## 현재 구조 vs 올바른 구조

### 현재 (틀림)

```python
build_acc() returns:
{
  "center": (0, 0),
  "diameter": 1.282,  # 최대값 하나만
  "members": {J, T, Y, O, Q, N},  # 모든 멤버
  "points": {
    "J": (0.5, 0.2),   # 모두 같은 원 위
    "T": (0.6, 0.3),
    "Y": (0.4, 0.5),
    "O": (-0.5, 0.2),
    "Q": (-0.6, 0.3),
    ...
  }
}

→ 하나의 원에 모든 점 표시
```

### 올바른 구조 (필요)

```python
build_acc() should return:
{
  "clusters": [
    {
      "members": {J, T},
      "diameter": 1.136,
      "theta": 18.0,
      "center": (0, 0),
      "points": {
        "J": (0.568, 0.0),  # d₁/2 * cos(0)
        "T": (-0.568, 0.0)
      }
    },
    {
      "members": {O, Q},
      "diameter": 1.205,
      "theta": 27.0,
      "center": (0, 0),
      "points": {
        "O": (0.603, 0.0),
        "Q": (-0.603, 0.0)
      }
    },
    {
      "members": {J, T, Y},
      "diameter": 1.282,
      "theta": 36.0,
      "center": (0, 0),
      "points": {
        "J": (0.641, 0.0),
        "T": (-0.641, 0.0),
        "Y": (0.0, 0.641)
      }
    }
  ]
}

→ 여러 개의 원, 각각 다른 diameter
```

## 해결 방법

### Option 1: build_acc() 수정 (추천)

**acc_core.py - build_acc() 수정**

```python
def build_acc(sub_dendro, inc_dendro, inc_matrix, unit=1.0):
    # 1) 모든 클러스터 추출
    clusters = extract_clusters_from_dendro(sub_dendro)

    # 2) 각 클러스터에 sim_inc, diameter, theta 할당
    decorate_clusters(clusters, inc_dendro, inc_matrix, unit=unit)

    # 3) 유사도 순 정렬
    clusters.sort(key=lambda c: c["sim_sub"], reverse=True)

    # 4) 각 클러스터를 독립적으로 배치
    positioned_clusters = []
    for c in clusters:
        # 각 클러스터를 원점 기준으로 배치
        positioned = place_cluster_on_circle(c)
        positioned_clusters.append(positioned)

    # ⚠️ 모든 클러스터 반환 (병합하지 않음!)
    return {
        "clusters": positioned_clusters,
        "all_members": set().union(*[c["members"] for c in clusters])
    }
```

**acc_gui.py - plot_acc_result() 수정**

```python
def plot_acc_result(self, acc_result):
    self.figure.clear()
    ax = self.figure.add_subplot(111)

    clusters = acc_result.get("clusters", [])

    # 각 클러스터마다 원 그리기
    colors = plt.cm.Set3(np.linspace(0, 1, len(clusters)))

    for idx, cluster in enumerate(clusters):
        center = cluster.get("center", (0, 0))
        diameter = cluster["diameter"]
        radius = diameter / 2.0
        points = cluster["points"]

        # 클러스터의 원 그리기
        circle = plt.Circle(center, radius, fill=False,
                           edgecolor=colors[idx], linewidth=2,
                           label=f"Cluster {idx+1}")
        ax.add_patch(circle)

        # 클러스터의 점들 그리기
        for member, (x, y) in points.items():
            ax.plot(x, y, 'o', markersize=10, color=colors[idx],
                   markeredgecolor='black', markeredgewidth=1.5)
            ax.text(x, y, f'  {member}', fontsize=10,
                   va='center', fontweight='bold')

    # 축 범위 설정 (가장 큰 diameter 기준)
    max_radius = max(c["diameter"]/2.0 for c in clusters)
    margin = max_radius * 0.3
    ax.set_xlim(-max_radius - margin, max_radius + margin)
    ax.set_ylim(-max_radius - margin, max_radius + margin)
    ax.set_aspect('equal')

    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_title('ACC Concentric Circles', fontsize=11, fontweight='bold')

    self.figure.tight_layout()
    self.canvas.draw()
```

### Option 2: 별도의 build_acc_multiCircle() 추가

기존 `build_acc()` 유지하고 새로운 함수 추가:

```python
def build_acc_multi_circle(sub_dendro, inc_dendro, inc_matrix, unit=1.0):
    """
    Build ACC with multiple concentric circles
    Returns list of positioned clusters instead of merged result
    """
    # ... (Option 1과 동일한 로직)
```

## 기대 효과

### Before (현재)

```
┌─────────────────────┐
│   Y                 │
│   J───T   O───Q  N  │  ← 모든 점이 하나의 원 위
│       ⭕            │
└─────────────────────┘

문제:
- ❌ 클러스터별 diameter 구분 없음
- ❌ 동심원 구조 표현 안 됨
- ❌ 논문의 핵심 개념 미반영
```

### After (수정 후)

```
┌─────────────────────┐
│       Y             │  ← Cluster 3 (큰 원)
│   J───+───T         │
│                     │
│     J───T           │  ← Cluster 1 (중간 원)
│                     │
│     O───Q           │  ← Cluster 2 (작은 원)
│                     │
│       +             │  ← Origin
└─────────────────────┘

개선:
- ✅ 각 클러스터가 고유한 diameter 원 가짐
- ✅ 동심원 구조 명확히 표현
- ✅ sim_inc 기반 diameter 시각화
- ✅ 논문의 핵심 개념 구현
```

## 추가 고려사항

### 1. 클러스터 필터링

```python
# 단일 멤버 클러스터는 제외 (acc_utils.py에 이미 구현됨)
def extract_clusters_from_dendro_filtered(root):
    clusters = extract_clusters_from_dendro(root)
    # Filter out single-member clusters
    return [c for c in clusters if len(c["members"]) >= 2]
```

### 2. 클러스터 정렬

```python
# sim_sub 기준 정렬 (높은 유사도 먼저)
clusters.sort(key=lambda c: c["sim_sub"], reverse=True)
```

### 3. 색상 구분

```python
# 각 클러스터마다 다른 색상
colors = plt.cm.Set3(np.linspace(0, 1, len(clusters)))
```

### 4. 겹침 처리

- 같은 member가 여러 cluster에 나타날 수 있음
- 가장 작은 클러스터의 위치 우선 표시
- 또는 모든 위치에 표시 (투명도 조정)

## 결론

현재 ACC 구현의 핵심 문제:
- ❌ **모든 클러스터를 하나로 병합**하여 단일 원 생성
- ❌ 각 클러스터의 고유한 **diameter 정보 손실**
- ❌ 논문의 핵심인 **동심원 구조** 미구현

해결 방법:
- ✅ `build_acc()`가 **모든 클러스터 리스트** 반환
- ✅ `plot_acc_result()`가 **여러 개의 원** 그리기
- ✅ 각 클러스터를 **독립적인 원**으로 시각화

**사용자가 요구한 "concentric circles" 구조를 올바르게 구현할 수 있습니다!**
