# 20251112 P21: ACC 알고리즘 재설계 (Option 1 접근법)

## 개요

ACC 알고리즘을 처음부터 재설계하여 더 직관적이고 단계별로 이해하기 쉬운 구조로 개선했습니다.

## 핵심 아이디어

### Option 1 접근법: 전역 최대 유사도 우선

각 단계에서 **전역적으로 가장 높은 유사도**를 가진 쌍을 선택합니다:
1. 배치되지 않은 두 area 간의 유사도
2. 클러스터와 배치되지 않은 area 간의 유사도
3. 두 클러스터 간의 유사도

## 알고리즘 단계

### Step 0: 초기 쌍 배치
- Subordinate matrix에서 가장 높은 유사도를 가진 두 area 선택
- **Radius 계산**: `radius = unit / subordinate_similarity`
  - 유사도가 높을수록 → 반지름이 작음 (더 밀집)
- **Angle 계산**: `angle = 180° × (1 - inclusive_similarity)`
  - 유사도가 높을수록 → 각도가 작음 (더 가까이)

### Step 1~N: 반복 병합

각 단계에서 다음 3가지 경우 중 가장 높은 유사도를 선택:

#### Case 1: 새로운 쌍 (New Pair)
- 두 area 모두 아직 배치되지 않음
- 독립적인 새 클러스터 생성
- Step 0과 동일한 방식으로 배치

#### Case 2: Area 추가 (Add Area)
- 기존 클러스터에 단일 area 추가
- 클러스터 내에서 가장 유사한 멤버 찾기
- 해당 멤버를 기준으로 새 area 배치
- 반지름은 클러스터 기존 값 유지

#### Case 3: 클러스터 병합 (Merge Clusters)
- 두 독립 클러스터를 하나로 병합
- 두 클러스터 간 가장 유사한 멤버 쌍 찾기
- 새로운 큰 반지름으로 스케일링
- 정렬 멤버를 기준으로 상대 위치 유지

## 구현 세부사항

### 파일: acc_core_new.py

#### 핵심 함수들

**1. find_highest_similarity_pair(sub_matrix)**
- 전체 matrix에서 가장 높은 유사도 쌍 찾기

**2. place_first_two_areas(area1, area2, sub_sim, inc_sim, unit)**
- 첫 두 area를 원 위에 배치
- 반지름과 각도 계산

**3. add_area_to_cluster(cluster, new_area, inc_matrix)**
- 기존 클러스터에 단일 area 추가
- 가장 유사한 멤버 기준으로 위치 계산

**4. merge_two_clusters(c1, c2, inc_matrix, unit)**
- 두 클러스터를 하나로 병합
- 정렬 멤버(alignment members) 찾기
- 스케일링 및 재배치

**5. find_highest_similarity_with_clusters(sub_matrix, inc_matrix, placed_areas, clusters)**
- 세 가지 경우 모두 고려하여 다음 최고 유사도 찾기
- 반환: (type, item1, item2, sub_sim, inc_sim)

**6. build_acc_iterative(sub_matrix, inc_matrix, unit, method)**
- 전체 알고리즘 실행
- 각 단계의 스냅샷 저장
- 반환: steps 리스트

## 테스트 결과

### 샘플 데이터 (J, T, Y, N, O, Q)

```
Step 0: INITIAL
  - J-T 쌍 배치 (sub=0.900, inc=0.880)
  - Radius: 1.111
  - Angle: 21.60°
  - Members: {J, T}

Step 1: NEW_PAIR
  - O-Q 쌍 배치 (독립 클러스터)
  - sub=0.850, inc=0.830
  - Radius: 1.176
  - Angle: 30.60°
  - Members: {O, Q}
  - Active clusters: 2개

Step 2: ADD_AREA
  - Y를 {J, T} 클러스터에 추가
  - sim=0.800 (Y-T 또는 Y-J 중 최대)
  - Members: {J, T, Y}
  - Active clusters: 2개

Step 3: ADD_AREA
  - N을 {O, Q} 클러스터에 추가
  - sim=0.750
  - Members: {N, O, Q}
  - Active clusters: 2개

Step 4: MERGE_CLUSTERS
  - {J, T, Y}와 {N, O, Q} 병합
  - sim=0.400 (두 클러스터 간 최대 유사도)
  - 정렬 멤버: J와 N (가장 유사한 쌍)
  - 새 radius: 1.765 (기존 최대값의 1.5배)
  - Final members: {J, T, Y, N, O, Q}
  - Active clusters: 1개
```

### 최종 좌표

```
J: ( 1.037, -1.428)
T: ( 1.037, -0.766)
Y: ( 0.945, -0.447)
N: ( 1.037,  1.428)
O: ( 1.362, -0.141)
Q: ( 1.362,  0.790)
```

## 장점

### 1. 단계별 명확성
- 각 단계가 독립적으로 이해 가능
- 시각화 및 디버깅 용이

### 2. 유사도 기반 결정
- 항상 가장 높은 유사도 우선
- 직관적이고 예측 가능

### 3. 유연한 구조
- 독립 클러스터 동시 관리
- 점진적 병합 지원

### 4. 수학적 일관성
- 반지름: 유사도에 반비례 (밀집도 표현)
- 각도: 유사도에 비례 (근접도 표현)

## 이전 알고리즘과의 차이점

### 이전 (acc_core.py)
- Dendrogram 구조에 의존
- 클러스터 추출 후 sim_sub 순서로 정렬
- 복잡한 병합 로직

### 새로운 (acc_core_new.py)
- Matrix에서 직접 작동
- 각 단계에서 전역 최대 유사도 선택
- 명확한 3가지 케이스 처리
- 독립 클러스터 관리

## 다음 단계

### 1. GUI 통합
- build_acc_iterative()를 acc_gui.py에 연결
- 단계별 시각화 지원

### 2. 파라미터 조정
- unit 값 실험
- 병합 시 스케일 팩터 조정 (현재 1.5)
- 각도 계산 공식 미세 조정

### 3. 검증
- 다양한 데이터셋으로 테스트
- 이전 알고리즘과 결과 비교
- 엣지 케이스 처리

### 4. 최적화
- 유사도 계산 캐싱
- 대규모 데이터셋 성능 개선

### 5. 문서화
- 수학적 근거 상세 설명
- 사용자 가이드 작성
- API 문서 생성

## 수식 정리

### 반지름 계산
```
radius = unit / subordinate_similarity

예: sub_sim = 0.9, unit = 1.0
    → radius = 1.0 / 0.9 = 1.111
```

### 각도 계산
```
angle = 180° × (1 - inclusive_similarity)

예: inc_sim = 0.88
    → angle = 180° × (1 - 0.88) = 21.6°
```

### 병합 시 정렬 각도
```
alignment_angle = 180° × (1 - similarity_between_clusters)

예: cluster1과 cluster2 간 sim = 0.4
    → alignment_angle = 180° × (1 - 0.4) = 108°
```

### 병합 시 반지름 스케일링
```
new_radius = max(radius1, radius2) × scale_factor

현재 scale_factor = 1.5 (실험적 값)
```

## 결론

Option 1 접근법을 완전히 구현하여 ACC 알고리즘의 모든 단계를 명확하게 정의했습니다:
1. ✅ 초기 쌍 배치
2. ✅ 독립 쌍 생성
3. ✅ Area 추가
4. ✅ 클러스터 병합

각 단계의 스냅샷을 저장하여 시각화 및 분석에 활용할 수 있습니다.
